use flowrs :: exec :: execution :: { Executor , StandardExecutor , ExecutionContext , ExecutionContextHandle } ; use flowrs :: exec :: node_updater :: { NodeUpdater , SingleThreadedNodeUpdater , MultiThreadedNodeUpdater } ; use flowrs :: flow :: flow :: Flow ; use flowrs :: nodes :: connection :: connect ; use flowrs :: nodes :: node :: { ChangeObserver , Context } ; use flowrs :: nodes :: node_description :: NodeDescription ; use flowrs :: sched :: { scheduler :: Scheduler , round_robin :: RoundRobinScheduler } ; use serde_json :: Value ; use std :: sync :: { Arc , Mutex } ; use std :: ffi :: { CString , CStr } ; use std :: os :: raw :: c_char ; use wasm_bindgen :: prelude :: * ;# [cfg (target_arch = "wasm32")] # [wasm_bindgen] extern "C" { # [wasm_bindgen (js_namespace = console)] fn log (s : & str) ; } # [cfg (target_arch = "wasm32")] macro_rules ! println { ($ ($ t : tt) *) => { log (format ! ($ ($ t) *) . as_str ()) ; } } # [cfg (target_arch = "wasm32")] # [wasm_bindgen] pub fn wasm_run () { let mut ctx = Box :: new (init ()) ; let node_updater = SingleThreadedNodeUpdater :: new (None) ; let scheduler = RoundRobinScheduler :: new () ; let res = ctx . executor . run (ctx . flow , scheduler , node_updater) ; } # [cfg (not (target_arch = "wasm32"))] # [no_mangle] pub extern "C" fn native_init () -> * mut ExecutionContextHandle { let ctx = Box :: new (init ()) ; Box :: into_raw (ctx) . cast () } # [cfg (not (target_arch = "wasm32"))] # [no_mangle] pub extern "C" fn native_run (num_workers : usize , ctx_handle : * mut ExecutionContextHandle) -> * const c_char { let mut ctx = unsafe { Box :: from_raw (ctx_handle . cast :: < ExecutionContext > ()) } ; let node_updater = MultiThreadedNodeUpdater :: new (num_workers) ; let scheduler = RoundRobinScheduler :: new () ; let res = ctx . executor . run (ctx . flow , scheduler , node_updater) ; CString :: new (format ! ("{:?}" , res)) . expect ("Cannot convert result to a C-String.") . into_raw () } # [no_mangle] pub unsafe extern fn native_free_string (ptr : * const c_char) { let _ = CString :: from_raw (ptr as * mut _) ; } # [cfg (not (target_arch = "wasm32"))] # [no_mangle] pub extern "C" fn native_cancel (ctx_handle : * mut ExecutionContextHandle) { let ctx = unsafe { Box :: from_raw (ctx_handle . cast :: < ExecutionContext > ()) } ; ctx . executor . controller () . lock () . unwrap () . cancel () } pub fn init () -> ExecutionContext { let co = ChangeObserver :: new () ; let change_observer = Some (& co) ; let context = Arc :: new (Mutex :: new (Context :: new ())) ; let data_str = "{\"timer_config_node\":{\"value\":{\"duration\":{\"nanos\":0,\"secs\":1}}},\"timer_token_node\":{\"value\":42}}" ; let data : Value = serde_json :: from_str (& data_str) . expect ("Failed to parse flow project data.") ; let timer_config_node_value : flowrs_std :: nodes :: timer :: TimerNodeConfig = serde_json :: from_value (data ["timer_config_node"] ["value"] . clone ()) . expect ("Could not create 'timer_config_node_value' from Json.") ; let timer_config_node = flowrs_std :: nodes :: value :: ValueNode ::< flowrs_std :: nodes :: timer :: TimerNodeConfig ,>:: new (timer_config_node_value , change_observer . clone ()) ; let timer_token_node_value : i32 = serde_json :: from_value (data ["timer_token_node"] ["value"] . clone ()) . expect ("Could not create 'timer_token_node_value' from Json.") ; let timer_token_node = flowrs_std :: nodes :: value :: ValueNode ::< i32 ,>:: new (timer_token_node_value , change_observer . clone ()) ; let debug_node = flowrs_std :: nodes :: debug :: DebugNode ::< i32 ,>:: new (change_observer . clone ()) ; let timer_node_timer = flowrs_std :: nodes :: timer :: SelectedTimer ::< i32 ,>:: new () ; let timer_node = flowrs_std :: nodes :: timer :: TimerNode ::< flowrs_std :: nodes :: timer :: SelectedTimer < i32 ,>, i32 ,>:: new (timer_node_timer , change_observer . clone ()) ; connect (timer_config_node . output . clone () , timer_node . config_input . clone ()) ; connect (timer_token_node . output . clone () , timer_node . token_input . clone ()) ; connect (timer_node . token_output . clone () , debug_node . input . clone ()) ; let mut flow = Flow :: new_empty () ; flow . add_node_with_id_and_desc (timer_config_node , 0u128 , NodeDescription { name : "timer_config_node" . into () , description : "timer_config_node" . into () , kind : "flowrs_std::nodes::value::ValueNode" . into () }) ; flow . add_node_with_id_and_desc (timer_token_node , 1u128 , NodeDescription { name : "timer_token_node" . into () , description : "timer_token_node" . into () , kind : "flowrs_std::nodes::value::ValueNode" . into () }) ; flow . add_node_with_id_and_desc (debug_node , 2u128 , NodeDescription { name : "debug_node" . into () , description : "debug_node" . into () , kind : "flowrs_std::nodes::debug::DebugNode" . into () }) ; flow . add_node_with_id_and_desc (timer_node , 3u128 , NodeDescription { name : "timer_node" . into () , description : "timer_node" . into () , kind : "flowrs_std::nodes::timer::TimerNode" . into () }) ; let executor = StandardExecutor :: new (co) ; ExecutionContext :: new (executor , flow) }